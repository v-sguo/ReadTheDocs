#!/usr/bin/env python3
# -*- coding: utf-8 -*-
#
# Amulet documentation build configuration file, created by
# sphinx-quickstart on Mon Apr  9 12:36:36 2018.
#
# This file is execfile()d with the current directory set to its
# containing dir.
#
# Note that not all possible configuration values are present in this
# autogenerated file.
#
# All configuration values have a default; values that are commented out
# serve to show the default.

import logging as pylogging
import os
import sys

# If extensions (or modules to document with autodoc) are in another directory,
# add these directories to sys.path here. If the directory is relative to the
# documentation root, use os.path.abspath to make it absolute, like shown here.
#
import git
from docutils import nodes
from packaging import version as pversion
from sphinx.util import logging

sys.path.insert(0, os.path.abspath(".."))


# -- General configuration ------------------------------------------------

# If your documentation needs a minimal Sphinx version, state it here.
#
# needs_sphinx = '1.0'

# Add any Sphinx extension module names here, as strings. They can be
# extensions coming with Sphinx (named 'sphinx.ext.*') or your custom
# ones.

from pkg_resources import get_distribution
from recommonmark.transform import AutoStructify

# __version__ = get_distribution("amlt").version
import sphinx_fontawesome

extensions = [  # 'sphinx.ext.autodoc',
  # 'sphinx.ext.doctest',
  "sphinx.ext.viewcode",
  "sphinx.ext.autodoc",
  "sphinx.ext.napoleon",
#   "sphinx_autodoc_typehints",
  "sphinx.ext.todo",
  "sphinx_fontawesome",
#   "sphinx_click.ext",
  # 'sphinx.ext.coverage',
  "sphinx.ext.mathjax",
#   "sphinx_multiversion",
  "sphinx_tabs.tabs",
  "sphinx-prompt",
  "sphinx_substitution_extensions",
  "sphinx_togglebutton",
]

autodoc_member_order = "bysource"
autodoc_default_flags = ["members", "show-inheritance"]
from marshmallow import Schema

autodoc_mock_imports = ["azure", "azureml", "click"]
nitpick_ignore = [
  ("py:class", "click.types.ParamType"),
  ("py:class", "click.core.Group"),
  ("py:class", "Command"),
  ("py:class", "enum.Enum"),
  ("py:class", "abc.ABC"),
  ("py:class", "tempfile.NamedTemporaryFile"),
  ("py:class", "queue.Queue"),
  ("py:class", "NoneType"),
]

# version_without_dev = __version__.partition(".dev")[0]
# rst_prolog = f"""
# # .. |nightly_version| replace:: {version_without_dev}.dev0
# .. |amulet| replace:: Amulet
# """

set_type_checking_flag = True

# Add any paths that contain templates here, relative to this directory.
templates_path = ["_templates"]

# The suffix(es) of source filenames.
# You can specify multiple suffix as a list of string:
#
source_parsers = {".md": "recommonmark.parser.CommonMarkParser"}
source_suffix = [".rst", ".md"]

# The master toctree document.
master_doc = "index"

# General information about the project.
project = "Amulet"
copyright = "2021, Microsoft"
author = "Microsoft"

# The version info for the project you're documenting, acts as replacement for
# |version| and |release|, also used in various other places throughout the
# built documents.
#
# The short X.Y version.
# version = __version__
# The full version, including alpha/beta/rc tags.
release = ""

# The language for content autogenerated by Sphinx. Refer to documentation
# for a list of supported languages.
#
# This is also used if you do content translation via gettext catalogs.
# Usually you set "language" from the command line for these cases.
language = "en"

# List of patterns, relative to source directory, that match files and
# directories to ignore when looking for source files.
# This patterns also effect to html_static_path and html_extra_path
exclude_patterns = ["_build", "_modules/amulet.rst"]

# The name of the Pygments (syntax highlighting) style to use.
pygments_style = "sphinx"

# If true, `todo` and `todoList` produce output, else they produce nothing.
todo_include_todos = True


# -- Options for HTML output ----------------------------------------------

# The theme to use for HTML and HTML Help pages.  See the documentation for
# a list of builtin themes.
#
html_theme = "sphinx_rtd_theme"

# Theme options are theme-specific and customize the look and feel of a theme
# further.  For a list of options available for each theme, see the
# documentation.
#
html_theme_options = {
#   "display_version": False,
  "logo_only": True,
  "style_nav_header_background": "#151033",
}

# Add any paths that contain custom static files (such as style sheets) here,
# relative to this directory. They are copied after the builtin static files,
# so a file named "default.css" will overwrite the builtin "default.css".
html_static_path = ["_static"]

# Custom sidebar templates, must be a dictionary that maps document names
# to template names.
#
# This is required for the alabaster theme
# refs: http://alabaster.readthedocs.io/en/latest/installation.html#sidebars
html_sidebars = {
  "**": [
    "about.html",
    "navigation.html",
    "relations.html",  # needs 'show_related': True theme option to display
    "searchbox.html",
    "donate.html",
  ]
}


# -- Options for HTMLHelp output ------------------------------------------

# Output file base name for HTML help builder.
htmlhelp_basename = "amltdoc"


# -- Options for LaTeX output ---------------------------------------------

latex_elements = {
  # The paper size ('letterpaper' or 'a4paper').
  #
  # 'papersize': 'letterpaper',
  # The font size ('10pt', '11pt' or '12pt').
  #
  # 'pointsize': '10pt',
  # Additional stuff for the LaTeX preamble.
  #
  # 'preamble': '',
  # Latex figure (float) alignment
  #
  # 'figure_align': 'htbp',
}

# Grouping the document tree into LaTeX files. List of tuples
# (source start file, target name, title,
#  author, documentclass [howto, manual, or own class]).
latex_documents = [
  (master_doc, "amlt.tex", "Amulet Documentation", "Microsoft", "manual"),
]


# -- Options for manual page output ---------------------------------------

# One entry per manual page. List of tuples
# (source start file, name, description, authors, manual section).
man_pages = [(master_doc, "amulet", "Amulet Documentation", [author], 1)]


# -- Options for Texinfo output -------------------------------------------

# Grouping the document tree into Texinfo files. List of tuples
# (source start file, target name, title, author,
#  dir menu entry, description, category)
texinfo_documents = [
  (
    master_doc,
    "Amulet",
    "Amulet Documentation",
    author,
    "Amulet",
    "One line description of project.",
    "Miscellaneous",
  ),
]


# def get_versions():
#   """
#   returns
#   - the list of versions to be built (only latest patch version for each unique (major/minor) version).
#   - the latest released version (i.e. no release candidates)
#   """
#   try:
#     repo = git.Repo("..")
#   except Exception:
#     return None, None
#   latest_patch = dict()
#   tags = []
#   for tag in git.tag.TagReference.list_items(repo):
#     tag = str(tag)
#     tag_version = pversion.parse(tag)
#     if isinstance(tag_version, pversion.LegacyVersion):
#       continue
#     tags.append(tag_version)
#   tags = sorted(tags)
#   for tag in tags:
#     # micro = tag.micro if hasattr(tag, "micro") else 0
#     latest_patch[(tag.major, tag.minor)] = (tag.micro, tag.post)
#   last_released_version = [t for t in tags if not t.is_prerelease][-1]
#   tags = [
#     t
#     for t in tags
#     if (t.micro, t.post) == latest_patch[(t.major, t.minor)]
#     and (t.major, t.minor) >= (8, 2)
#   ]
#   return list(f"v{t}" for t in tags), f"v{last_released_version}"


# -- Options for sphinxcontrib versioning
smv_show_banner = True
smv_banner_greatest_tag = False

# tmp = get_versions()
# if tmp[0]:
#   print("VERSIONS: ", tmp)
#   smv_tag_whitelist = rf'^({"|".join(tmp[0])})$'
# smv_released_pattern = r"^tags/.*$"
# smv_branch_whitelist = r"^(main|sing/amlt8)$"
# smv_remote_whitelist = r"^.*$"
# smv_prefer_remote_refs = True
# smv_prebuild_command = "test -d amlt && sphinx-apidoc -MTP -o doc/api amlt || sphinx-apidoc -MTP -o doc/api phillytools"


# # ####### :numref: fallback ########
# # The following hook functions add some simple handling for the :numref:
# # directive for Sphinx versions prior to 1.3.1. The functions replace the
# # :numref: reference with a link to the target (for all Sphinx doc types).
# # It doesn't try to label figures/tables.
# def cluster_role(reftype, rawtext, text, lineno, inliner):
#   """
#   Add a Sphinx role to handle numref references. Note, we can't convert
#   the link here because the doctree isn't build and the target information
#   isn't available.
#   """
#   # Add an identifier to distinguish numref from other references.
#   newnode = nodes.reference(rawtext, text, refuri="_cluster_#%s" % text, internal=True)
#   return [newnode], []


def process_cluster(app, doctree, from_docname):
  """
  Process the numref nodes once the doctree has been built and prior to
  writing the files. The processing involves replacing the numref with a
  link plus text to indicate if it is a Figure or Table link.
  """

  # Iterate over the reference nodes in the doctree.
  for node in doctree.traverse(nodes.reference):
    target = node.get("refuri", "")

    # Look for numref nodes.
    if target.startswith("_cluster_#"):
      target = target.replace("_cluster_#", "")

      # Get the target label and link information from the Sphinx env.
      data = app.builder.env.domains["std"].data
      docname, label = data["anonlabels"].get("target-name-" + target, ("", ""))
      relative_url = app.builder.get_relative_uri(from_docname, docname)

      caption = node.astext()

      # New reference node with the updated link information.
      newnode = nodes.reference(
        "", caption, refuri="%s#%s" % (relative_url, label), internal=True
      )
      node.replace_self(newnode)


# Workaround for https://github.com/agronholm/sphinx-autodoc-typehints/issues/123
# When this https://github.com/agronholm/sphinx-autodoc-typehints/pull/153
# gets merged, we can remove this
class FilterForIssue123(pylogging.Filter):
  def filter(self, record: pylogging.LogRecord) -> bool:
    # You probably should make this check more specific by checking
    # that dataclass name is in the message, so that you don't filter out
    # other meaningful warnings
    return not record.getMessage().startswith("Cannot treat a function")


# logging.getLogger("sphinx_autodoc_typehints").logger.addFilter(FilterForIssue123())
# End of a workaround


def setup(app):
  app.add_config_value(
    "recommonmark_config",
    {
      # 'url_resolver': lambda url: github_doc_root + url,
      "auto_toc_tree_section": "Contents",
      "enable_eval_rst": True,
    },
    True,
  )
  app.add_transform(AutoStructify)
  app.add_css_file("custom.css")
#   app.add_role("cluster", cluster_role)
  app.connect("doctree-resolved", process_cluster)
